#!/usr/bin/env python3
"""
Build lightweight HTML report template for --html flag.
No WASM, no parsing, no filters - just embedded data + UI.
"""

import base64
import gzip
import os
import re
import sys

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_DIR = os.path.dirname(SCRIPT_DIR)
WEB_DIR = os.path.join(PROJECT_DIR, "web")
ZSTD_DECODER = os.path.join(SCRIPT_DIR, "fzstd.min.js")

def minify_css(css):
    """Simple CSS minification"""
    css = re.sub(r'/\*.*?\*/', '', css, flags=re.DOTALL)
    css = re.sub(r'\s+', ' ', css)
    css = re.sub(r'\s*([{};:,])\s*', r'\1', css)
    css = re.sub(r';\s*}', '}', css)
    return css.strip()

def minify_js(js):
    """Simple JS minification (conservative)"""
    js = re.sub(r'(?<!:)//[^\n]*', '', js)
    js = re.sub(r'/\*.*?\*/', '', js, flags=re.DOTALL)
    js = re.sub(r'\n\s*\n', '\n', js)
    js = re.sub(r'^\s+', '', js, flags=re.MULTILINE)
    return js.strip()

def remove_wasm_code(js):
    """Remove WASM loading and parsing code"""
    # Remove WASM initialization
    js = re.sub(r'window\.wasmReady\s*=.*?(?=\n\s*(?:window\.|function |const |let |var ))', '', js, flags=re.DOTALL)
    js = re.sub(r'async function initWasm\(\).*?(?=\n\s*(?:window\.|function |const |let |var ))', '', js, flags=re.DOTALL)
    js = re.sub(r'function cacheWasmForWorkers.*?(?=\n\s*(?:window\.|function |const |let |var ))', '', js, flags=re.DOTALL)

    # Remove worker-related code
    js = re.sub(r'let worker(?:Pool|s)\s*=.*?;', '', js)
    js = re.sub(r'function.*?Worker.*?\{.*?\}', '', js, flags=re.DOTALL)

    # Remove file parsing functions
    js = re.sub(r'async function parseFile\(.*?\{.*?\}', '', js, flags=re.DOTALL)
    js = re.sub(r'function processChunk.*?\{.*?\}', '', js, flags=re.DOTALL)

    return js

def remove_filter_code(js):
    """Remove filter UI and logic"""
    # Keep data rendering but remove filter application
    # We'll keep the filter bar hidden via CSS instead of removing HTML
    js = re.sub(r'function applyFilters\(\).*?(?=\n\s*(?:window\.|function |const |let |var ))', '', js, flags=re.DOTALL)
    js = re.sub(r'function updateApplyButton\(\).*?(?=\n\s*(?:window\.|function |const |let |var ))', '', js, flags=re.DOTALL)

    return js

def remove_file_input_code(js):
    """Remove file input handling"""
    js = re.sub(r'function handleFile.*?(?=\n\s*(?:window\.|function |const |let |var ))', '', js, flags=re.DOTALL)
    js = re.sub(r'document\.getElementById\([\'"]fileInput[\'"]\).*?;', '', js)

    return js

def build_report_template():
    print("Building HTML report template...")
    print("=" * 50)

    # Read source files
    index_path = os.path.join(WEB_DIR, "index.html")
    styles_path = os.path.join(WEB_DIR, "styles.css")
    app_path = os.path.join(WEB_DIR, "app.js")
    uplot_path = os.path.join(SCRIPT_DIR, "uplot.min.js")

    with open(index_path, 'r') as f:
        html = f.read()
    with open(styles_path, 'r') as f:
        css = f.read()
    with open(app_path, 'r') as f:
        js = f.read()
    with open(uplot_path, 'r') as f:
        uplot = f.read()
    with open(ZSTD_DECODER, 'r') as f:
        fzstd = f.read()

    print(f"Source CSS:  {len(css):,} bytes")
    print(f"Source JS:   {len(js):,} bytes")
    print(f"uPlot:       {len(uplot):,} bytes")
    print(f"fzstd:       {len(fzstd):,} bytes")

    # Gzip the zstd decoder
    fzstd_gzip = gzip.compress(fzstd.encode('utf-8'), compresslevel=9)
    fzstd_b64 = base64.b64encode(fzstd_gzip).decode('ascii')
    print(f"fzstd gzip:  {len(fzstd_gzip):,} bytes → {len(fzstd_b64):,} b64")

    # Extract body content (between <body> and scripts)
    body_match = re.search(r'<body>(.*?)<script', html, re.DOTALL)
    body = body_match.group(1).strip() if body_match else ""

    # Modify body for report mode:
    # 1. Change header subtitle (remove "WebAssembly demo" text)
    body = re.sub(
        r'WebAssembly demo – all processing happens locally in your browser',
        'Report generated by CLI',
        body
    )

    # Don't remove any JS functions - the aggressive regex was breaking renderResults
    # Just minify the JS as-is (unused functions won't hurt)

    # Minify
    css_min = minify_css(css)
    js_min = minify_js(js)

    # Remove WASM loading code entirely for report mode
    # Replace the fetch chain with a no-op
    js_min = re.sub(
        r"fetch\('quellog\.wasm'\).*?alert\('Failed to load WASM module'\);\n\}\);",
        "/* WASM disabled in report mode */",
        js_min,
        flags=re.DOTALL
    )

    print(f"Minified CSS: {len(css_min):,} bytes ({len(css_min)/len(css)*100:.0f}%)")
    print(f"Cleaned JS:   {len(js_min):,} bytes ({len(js_min)/len(js)*100:.0f}%)")

    # Build template with JSON placeholder and zstd decompression
    template = f'''<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>quellog Report</title>
<style>{css_min}</style>
<style>
/* Hide interactive elements in report mode */
.filter-bar, #fileInputSection, #newFileBtn {{ display: none !important; }}
#app {{ margin-top: 0; }}
/* Disable WASM-dependent features */
.drop-zone {{ display: none !important; }}
</style>
</head>
<body>
{body}
<script>{uplot}</script>
<script>
// Report mode: skip WASM initialization
window.REPORT_MODE = true;
window.wasmReady = true;
window.quellogVersion = function() {{ return 'CLI Report'; }};
window.parseLogFile = function() {{ console.warn('WASM not available in report mode'); }};
</script>
<script>
// Embedded compressed report data (zstd + base64, injected by Go)
const COMPRESSED_DATA = "{{{{REPORT_JSON_DATA}}}}";
const ZSTD_DECODER_GZIP_B64 = "{fzstd_b64}";

// Load zstd decoder (gzipped and base64-encoded)
async function loadZstdDecoder() {{
    try {{
        // Decode base64
        const binaryString = atob(ZSTD_DECODER_GZIP_B64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {{
            bytes[i] = binaryString.charCodeAt(i);
        }}

        // Decompress with native DecompressionStream
        const stream = new DecompressionStream('gzip');
        const writer = stream.writable.getWriter();
        writer.write(bytes);
        writer.close();

        const reader = stream.readable.getReader();
        const chunks = [];
        while (true) {{
            const {{ done, value }} = await reader.read();
            if (done) break;
            chunks.push(value);
        }}

        // Concatenate chunks
        const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {{
            result.set(chunk, offset);
            offset += chunk.length;
        }}

        // Decode to string and eval (loads fzstd library)
        const code = new TextDecoder().decode(result);
        eval(code);
    }} catch (err) {{
        console.error('Failed to load zstd decoder:', err);
        throw err;
    }}
}}

// Decompress base64 + zstd data
async function decompressData(base64Data) {{
    try {{
        // Load zstd decoder first
        await loadZstdDecoder();

        // Decode base64
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {{
            bytes[i] = binaryString.charCodeAt(i);
        }}

        // Decompress with fzstd
        const decompressed = fzstd.decompress(bytes);

        // Decode to string and parse JSON
        const jsonString = new TextDecoder().decode(decompressed);
        return JSON.parse(jsonString);
    }} catch (err) {{
        console.error('Failed to decompress data:', err);
        throw err;
    }}
}}
</script>
<script>{js_min}</script>
<script>
// Auto-decompress and render on load
if (COMPRESSED_DATA) {{
    console.log('Decompressing embedded report data...');
    decompressData(COMPRESSED_DATA).then(data => {{
        console.log('Report data loaded successfully');
        analysisData = data;  // Required for showQueryModal
        data._parseTimeMs = data.meta.parse_time_ms || 0;
        renderResults(data, data.meta.filename || 'Report', data.meta.filesize || 0, true);
    }}).catch(err => {{
        console.error('Failed to load report:', err);
        alert('Failed to load report data: ' + err.message);
    }});
}}
</script>
</body>
</html>'''

    # Write output (to output/ directory for Go embed)
    output_dir = os.path.join(PROJECT_DIR, "output")
    output_path = os.path.join(output_dir, "report_template.html")
    with open(output_path, 'w') as f:
        f.write(template)

    size = os.path.getsize(output_path)
    print()
    print("=" * 50)
    print(f"Output: {output_path}")
    print(f"Template size: {size:,} bytes ({size/1024:.1f} KB)")
    print("Ready for Go embed!")

if __name__ == "__main__":
    build_report_template()
